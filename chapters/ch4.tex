\chapter{基于压缩图的轻量级索引MWStar}
\label{ch4}
本章具体讨论了我们提出的全局与局部MWstar索引方法以及图压缩算法。在基于TopK密度剪枝的连续子图匹配问题中，如何高效地查询和更新子图匹配结果一直是一个挑战。
为了提升子图匹配的效率，我们提出了一种轻量级的MWstar索引方法。
该方法通过对星形子结构的部分匹配进行高效的索引，从而能够实现快速的增量更新和密度剪枝。
本章将详细介绍该方法的设计与实现，包括全局版本和局部版本的优化过程，并最终构建基于密度上限的筛选函数。
首先，在第\ref{mwstar:star_subquery}节中，我们将讨论星形结构子图及其部分匹配的概念。
在子图匹配问题中，星形结构子图是一类具有较强结构特征的子图。
理解星形结构子图的匹配过程能够为优化后续的匹配算法提供理论依据。
接着，在第\ref{mwstar:global}节中，我们将详细阐述第一个全局MWstar版本，该版本维护每个特定星形子结构的所有部分匹配的最大权重。
全局MWstar方法通过集中式的索引管理，可以为大规模图数据提供高效的查询和匹配操作。
在第\ref{mwstar:local}节中，我们将把这个初步版本优化为局部版本，以实现更好的基于密度的剪枝能力。
局部版本相较于全局版本，动态维护了索引密度上限，在复杂的动态图环境中，它能够有效地降低重复计算的开销，从而提升整体的计算效率。
我们结合全局和局部MWstar，构建最终的密度上限函数，能够在图数据动态变化时实时进行剪枝，更新子图匹配结果，并根据密度优先级进行高效筛选。
最后，我们介绍了一种图压缩策略，通过压缩图生成候选子图，该子图大小的规模远小于原始图。并且在该子图上对于轻量级索引的维护步骤仍与原始图相同，
其巧妙利用图压缩策略对候选节点的筛选能力以及轻量级索引对部分匹配的剪枝能力，大幅度提升了筛选top-k最高密度子图的效率。

\section{MWSTAR：CSM-TopK的轻量级索引}

\begin{figure}[h!]
\def\wscorevone{0.48}
\centering
\begin{subfigure}[t]{\wscorevone\linewidth}
\centering
\resizebox{\linewidth}{!}
{
\includegraphics{\csmfolder e_qstar.pdf}
}
\caption{Qstar示例}
\label{fig:qstar}
\end{subfigure}
\begin{subfigure}[t]{\wscorevone\linewidth}
\centering
\resizebox{\linewidth}{!}
{
\includegraphics{\csmfolder e_dstar.pdf}
}
\caption{Dstar示例}
\label{fig:dstar}
\end{subfigure}
\caption{MWstar在查询图和数据图中的示例}
\label{fig:exp:mwstar}
\end{figure}

\subsection{星形结构子图与部分匹配}
\label{mwstar:star_subquery}

\begin{definition}[星形结构子图]\label{def:star-subquery}
对于查询$Q$和匹配序列$\Phi=\{u_1, u_2, \cdots, u_{|Q|} \}$，我们为每个查询顶点$u_i$定义其在$\Phi$下的星形结构子图$Qstar_{\Phi}(u_i)$，
其包含顶点$LN(u_i) \cup {u_i}$以及连接$u_i$与其左邻居的边，即：$V_{Qstar_{\Phi}(u_i)} = LN(u_i) \cup \{u_i\}$，$E_{Qstar_{\Phi}(u_i)} = \{(u_i, u_j)\ |\ u_j\in LN(u_i)\}$。
当上下文清晰时，我们可以用$Qstar(i)$表示相应的子图。
\end{definition}

图\ref{fig:qstar}展示了在匹配序列为\{$u_1$, $u_2$, $u_3$, $u_4$\}时，$Qstar(3)$和$Qstar(4)$的示例。

考虑一个部分匹配$g^i=\{v_1, v_2, \cdots, v_i\}$，在匹配序列$\Phi$下，它匹配查询$q^i=\{u_1, u_2, \cdots, u_{i}\}$。
对于查询顶点$u_{i^\prime}$（$1 \leq i^\prime \leq i$），
假设$Qstar(i^\prime) = \{u_{x_1}, u_{x_2}, \cdots, u_{x_j}\}$（$j = |LN(u_{i^\prime})|$）。
对于$g^i$的子图$g^\prime = {v_{x_1}, v_{x_2}, \cdots, v_{x_j}}$（即$g^\prime \subseteq g^i$），如果$g^\prime$匹配$Qstar(i^\prime)$，且每个$v_{x_{j^\prime}}$映射到$u_{x_{j^\prime}}$（$1 \leq i^\prime \leq i$），则我们称$g^\prime$为$g^i$中在$u_{i^\prime}$下的星形部分匹配，记作$Dstar_{\Phi}(g^i, i^\prime)$。
当上下文明确时，我们也可以简化为$Dstar(g^i, i^\prime)$。
图\ref{fig:dstar}展示了在匹配$g=\{v_1, v_2, v_8, v_{1001}\}$时的$Dstar(g, 3)$和$Dstar(g, 4)$的示例。

\subsection{全局MWstar索引}
\label{mwstar:global}

接下来我们讨论全局MWstar索引的构建与应用。
对于查询$Q$的一个子查询$q^i$，在匹配序列$\Phi$下，$q^i$可以被分解为一系列的星型子图$Qstar(i^\prime)$（$1 \leq i^\prime \leq i$），即：

\[
	q^i = Qstar(1)\cup Qstar(2) \cdots \cup Qstar(i)
\]

实际上，对于任何两个查询顶点$u_{i_1}$和$u_{i_2}$（$i_1 \neq i_2$），根据星形子图的定义，有$E_{Qstar(i_1)} \cap E_{Qstar(i_2)} = \emptyset$。
对于匹配$q^i$的部分匹配$g^i$，通过这种分解方式，我们可以相应地将$g^i$分解为：

\begin{equation} \label{equation:dstar-decompose}
    g^i = Dstar(g^i, 1)\cup Dstar(g^i, 2) \cdots \cup Dstar(g^i, i)
\end{equation}

其中$Dstar(g^i, i^\prime)$匹配$Qstar(i^\prime)$（$1 \leq i^\prime \leq i$），并且对于$1 \leq i_1 < i_2 \leq i$，$E_{Dstar(g^i, i_1)} \cap E_{Dstar(g^i, i_2)} = \emptyset$。

通过对$g^i$的分解，我们可以计算其密度，如下所示：
\[
	den(g^i) = \sum\nolimits_{1\leq i^\prime\leq i} \left(den(Dstar(g^i,i^\prime))\right)
\] 

我们使用$den(Qstar(j))$来表示$Qstar(j)$的最大匹配权重，即：
\[
	den(Qstar(j)) = \max\nolimits_{g^\prime \in A_{G_t, Qstar(j)}} \left(den(g^\prime)\right)
\]


基于此，我们可以提出以下定理，用于设计基于全局MWstar的剪枝策略。

\begin{algorithm}[h!]
    \small
    \caption{带$gBound$的递归搜索}
    \label{alg:find-dense-matches-gBound}
    \SetKwBlock{iFunc}{Procedure}{End Procedure}
    \iFunc(FindDenseMatches-Global{(}$G_t, Q, \Phi, g^i, A, k${)})
    {
    设$g_{min}$为$A$中权重最小的匹配 \
    \If{$|g^i|=|V_Q|$}{
    \If{$|A|<k \lor den(g_{min}) < den(g^i)$ } {
    将$g^i$添加到$A$中. \\
    从$A$中移除$g_{min}$ if $|A|>k$\\
    }
    \Return
    }
    \If{$|A|=k \land gBound(g^i)\leq den(g_{min})$}{\label{code:B-basic-begin}
    \Return \label{code:B-basic-end}
    }
    执行算法\ref{alg:find-dense-matches}中第\ref{code:base-extension:begin}至第\ref{code:base-extension:end}行相同的操作，扩展$g^i$为一系列的$g^{i+1}$以进行进一步搜索 \\
    \Return
    }
\end{algorithm}


\begin{theorem} \label{theorem:global-mwstar}
假设$g^i$是$\Phi$下与$q^i$匹配的部分匹配，并且$g_{max}$是包含$g^i$的最大密度的完全匹配。那么，我们可以得出结论：
\[
	den(g_{max}) \leq den(g^i) + \sum\nolimits_{j=i+1}^{|V_Q|} \left(den(Qstar(j))\right)
\]

\end{theorem}

\begin{proof}
我们将$g_{max}$分解为：
\[
	g_{max} =   \bigcup\nolimits_{j=1}^{|V_Q|} Dstar(g_{max}, j)
\]
然后：
\begin{equation*}
    \begin{aligned}
      den(g_{max}) & =  \sum\nolimits_{j=1}^{|V_Q|} \left( den(Dstar(g_{max}, j)) \right)  \\
        & =  den(g^i) + \sum\nolimits_{j=i+1}^{|V_Q|} \left( den(Dstar(g_{max}, j)) \right) \\
        & \leq den(g^i) + \sum\nolimits_{j=i+1}^{|V_Q|} \left( den(Qstar(j)) \right) 
    \end{aligned}
  \end{equation*}
  \end{proof}

接下来我们给出相应密度的上界，以及利用密度上界进行递归搜索的过程。



\textbf{密度的上界}。 根据定理 \ref{theorem:global-mwstar}，对于每一个部分匹配 $g^i$，我们可以得到包含 $g^i$ 的完全匹配的密度上界，记作 $gBound_{G_t, Q, \Phi}(g^i)$，该上界表示对应星形子图中部分匹配的最大密度：
  \begin{equation*}
	\begin{multlined}
	 gBound_{G_t, Q, \Phi}(g^i) =  \\ den(g^i) + \sum\nolimits_{i+1\leq j\leq |V_Q|} \left(den(Qstar(j))\right)
	\end{multlined}
  \end{equation*}
  在上下文明确时，我们也可以简写为 $gBound(g^i)$。
  
  \textbf{基于上界的递归搜索}。 在我们的搜索过程中，对于每个部分匹配 $g^i$，如果 $gBound(g^i)$ 在当前已存在的 $G_t$ 匹配的密度排名中未能进入前 $k$ 名，，则我们可以安全地剪枝 $g^i$（详见算法 \ref{alg:find-dense-matches-gBound}  第 \ref{code:B-basic-begin}-\ref{code:B-basic-end}行）。
  
  对于每一种匹配顺序 $\Phi$，我们可以在 $Qstar(i)$（$1 \leq i \leq |V_Q|$）下维护相应的星形结构子图的最大密度，这实际上构成了全局MWstar。
  显然，全局 MWstar 的空间开销是 $O(|E_Q|*|V_Q|)$，这一开销可以忽略不计的。

    算法 \ref{alg:base-mwstar:update} 描述了全局 MWstar 索引的维护过程，特别是在增量更新时如何高效地维护星形子图的部分匹配。
    该算法通过输入的操作 $o_t = (op, v_1, v_2)$ 来更新全局 MWstar，其中操作类型 $op$ 可以是插入（+）或删除（-）。
    对于每一种操作，算法执行相应的步骤来保持全局 MWstar 中每个部分匹配的最大密度。
    
    假设 $(v_1, v_2)$ 匹配 $(u_{i_1}, u_{i_2})$: 
     如果 $o_t$ 是插入操作，
     那么对于每个匹配序列 $\Phi$，如果 $u_{i_1}$ $\in LN(u_{i_2})$（我们在此省略对称情况的讨论），
     则我们可以计算所有与 $Qstar(i_2)$匹配的所有新的星形结构的部分匹配（其中 $(v_1, v_2)$ 匹配 $(u_{i_1}, u_{i_2})$）。
     且如果 $g^\prime$ 是其中最密的部分匹配，当 $den(g^\prime) > den(Qstar(i))$ 时，我们更新 $den(Qstar(i))$。
     
     具体来说，如果 $N_{G_t}(v_2)$ 按邻接标签和对应边权重排序的话（见算法 \ref{alg:base-mwstar:update} 中 第\ref{code:basic-sorted:begin}-\ref{code:basic-sorted:end}行），
     则使用$v_2$ 匹配 $u_{i_2}$来计算这样的 $g^\prime$，其所需的时间复杂度为 $O(|N_{G_t}(v_2)|)$ 。
     由于存在 $|E_Q|$ 种匹配序列，因此边插入时全局 MWstar 的维护开销为 $O(|E_Q|*d_t)$，其中 $d_t$ 是 $G_t$ 的平均度数。
     
     如果 $o_t$ 是删除操作，
     删除的 $(v_1, v_2)$ 可能会导致 $den(Qstar(i))$ 过期。
     为了应对这一情况，一种简单的策略是每次删除操作重新计算 $den(Qstar(i))$。
     然而这种方法效率很低，因为它要求对整个图 $G_t$ 进行扫描，开销为 $O(|V_{G_t}|d_t)$，即 $O(E_{G_t})$，其复杂度与图中的边数 $E_{G_t}$ 成线性关系。

     \begin{algorithm}[H]
        \scriptsize
        \caption{全局 MWstar 维护}
        \label{alg:base-mwstar:update}
        \KwIn{ $G_t$, $Q$ 和 $o_t={op, v_1, v_2}$}
        \KwOut{更新后的全局 MWstar}
        \If{$op = +$}{
          \ForEach{$(u_{i_1},u_{i_2})\in E_{Q}$ 匹配 $(v_1, v_2)$} {
              \ForEach{匹配顺序 $\Phi$}{
                  \If{$u_{i_1}\in LN(u_{i_2})$}{
                      UpdateDensity($v_{2}$, $u_{i_2}$,$\Phi$) \\
                  }
                  \uElse { 
                      UpdateDensity($v_{1}$, $u_{i_1}$,$\Phi$) \\
                  }
              }
          }
      } % If  
      \If{$op=-$}{
              设 $g^\prime$ 表示 $A_{G_t, Qstar(i)}$ 中标记为最密集的部分匹配（即 $den(g)=den(Qstar(i))$） \label{code:record-denest} \\
              \If{$(v_1,v_2)\notin E_{g^\prime}$}{ \label{code:not-hit-return:begin}
                  \Return \label{code:not-hit-return:end}
              }   
             \ForEach{$v\in V_{G_t}$}{
                     \ForEach{$u\in V_Q$}{
                         \If{$L(v) = L(u)$}{
                             \ForEach{匹配顺序 $\Phi$}{
                                 updateDensity($v$, $u$, $\Phi$)
                             }
                         }
                     }
             }
           }
      
      \If{$op = +$}{
          \ForEach{$(u_{i_1},u_{i_2})\in E_{Q}$ 匹配 $(v_1, v_2)$} {
              \ForEach{匹配顺序 $\Phi$}{
                  \If{$u_{i_1}\in LN(u_{i_2})$}{
                      UpdateDensity($v_{2}$, $u_{i_2}$,$\Phi$) \\
                  }
                  \uElse { 
                      UpdateDensity($v_{1}$, $u_{i_1}$,$\Phi$) \\
                  }
              }
          }
      } % If  
      
      \SetKwFunction{FupdateMWstar}{updateDensity}
      \SetKwProg{Fn}{Function}{:}{\KwRet}
      \Fn{\FupdateMWstar{$u_{i}$,$v_{j}$,$\Phi$}}{
           /* 为每个 $v\in V_{G_t}$ 保持其邻接节点和对应边权重的排序是很简单的 */   \label{code:basic-den-update:begin}  \label{code:basic-sorted:begin}\\
           假设 $LN(u_i) =$ \{$u_{i_1}$, $u_{i_2}$, $\cdots$, $u_{i_x}$\} \\
           遍历 $N_{G_t}(v_j)$ 一次，计算出 $x$ 个不同的顶点 {$v_{j_1}$, $v_{j_2}$, $\cdots, v_{j_x}$}
           其中 $L(v_{j_{x^\prime}}) = L(u_{i_{x^\prime}})$ ($1\leq x^\prime\leq x$)   \label{code:basic-sorted:end} \\
           \If{这 $x$ 个顶点存在}{
           令 $g^\prime$ 表示由边从 $v_j$ 到 \{$v_{j_1}$, $v_{j_2}$, $\cdots, v_{j_x}$\} 组成的子图 \\
           \If{$den(g^\prime)>den(Qstar(i))$}{
           $den(Qstar(u_i))$ = $den(g^\prime)$ \\
           将 $g^\prime$ 标记为 $Qstar(i)$ 的最密匹配
           }
           }
           \uElse{
           $den(Qstar(u_i)) = 0$; \label{code:basic-den-update:end}
           }
           }
    \end{algorithm}
     
     为了提高效率，我们采取了另一种策略：始终记录 $A_{G_t, Qstar(i)}$ 中的部分匹配 $g^\prime$，它的密度为$den(Qstar(i))$（见算法 \ref{alg:base-mwstar:update} 行 \ref{code:record-denest}）。
     因此，当 $(v_1, v_2) \notin E_{g^\prime}$ 时，我们可以避免重新计算 $den(Qstar(i))$ 的高开销（见算法 \ref{alg:base-mwstar:update}  第 \ref{code:not-hit-return:begin}-\ref{code:not-hit-return:end}行）。
     通常，重新计算的概率是 $|E_{g^\prime}|/|E_{G_t}|$，即 $|LN(u_{i_2})|/|E_{G_t}|$。
     因此，重新计算的平均开销是 $O(|E_{G_t}|)*(|LN(u_{i_2})|/|E_{G_t}|)$，即 $O(|LN(u_{i_2})|)$。
     由于存在 $|E_Q|$ 种匹配序列，每次删除操作的平均开销为 $O(|E_Q|*|LN(u_{i_2})|)$。
         
     通过上述优化，我们的全局 MWstar以恒定的空间和几乎恒定的更新时间为代价，为每个部分匹配 $g^i$ 提供了 $gBound(g^i)$ 作为上界，
     基于该上界进行剪枝，减少了不必要的搜索，从而大大提高了搜索效率。
     该全局 MWstar 索引是我们方案的简化版本。接下来的 \ref{mwstar:local} 节中，我们将进一步优化此方案，提出一个局部版本的 MWstar，并设计一个面向 CSM-TopK 的搜索算法，其密度上限 $lBound$ 比 $gBound$ 更加紧凑，从而进一步提升搜索效率。

\subsection{局部MWstar索引}
\label{mwstar:local}
我们设计了一种局部MWstar（Local MWstar），它可以与全局 MWstar 结合使用，从而构建一个更紧密的密度上界。
局部MWstar通过在部分匹配过程中动态维护局部密度上界来提升匹配过程的效率和精确度。
我们用 $lBound(g^i)$ 表示部分匹配 $g^i$ 的新上界，该上界通常比全局 MWstar 的上界更加严格。
通过这种方式，局部MWstar不仅优化了密度计算，还为后续的查询操作提供了更高效的索引支持。
接下来，我们首先介绍局部 MWstar 索引的定义，并在此基础上提出一种面向 CSM-TopK 查询的搜索策略，利用 $lBound$ 函数进行优化。


\textbf{局部MWstar的定义}
局部 MWstar 是全局 MWstar 的扩展。
在全局 MWstar 中，对于每种匹配顺序 $\Phi$，我们维护不同子查询 $Qstar(i)$（$1\leq i\leq |V_Q|$）下星形结构部分匹配的最大权重。
而在局部 MWstar 中，我们针对每个特定的数据顶点维护类似的最大权重分布。

具体而言，给定匹配序列 $\Phi$ 和子查询 $Qstar(i)$，对于每个数据图中的顶点 $v$，我们维护所有匹配 $Qstar(i)$ 并且 $v$ 映射到 $u_i$ 的部分匹配 $g^\prime$ 的最大密度，记作 $den(Qstar(i), v)$ 。
例如，在图 \ref{fig:csm-topk} 中的运行示例，其中 $v_5$ 和相应的子查询 $Qstar(3)$（如图 \ref{fig:qstar} 所示）。存在两个子图,匹配 $Qstar(3)=\{u_1, u_2, u_3\}$，其中 $v_5$ 映射到 $u_3$：

     （1）$g_1^\prime=\{v_1, v_2, v_5\}$，密度 $den(g_1^\prime) = 40$

     （2）$g_2^\prime=\{v_1, v_3, v_5\}$，密度 $den(g_2^\prime) = 50$。

由于 $den(g_1^\prime)= 40 < den(g_2^\prime)=50$，因此我们设定 $den(Qstar(3), v_5) = 50$。

此外，对于具有标签 $L(u_i)$的顶点集合 $V^\prime$，我们可以使用$den(Qstar(i), V^\prime)$来表示任何$v\in V^\prime$的最大$den(Qstar(i), v)$，即:
\begin{equation}\label{equation:den-qstar-v}
	den(Qstar(i), V^\prime) = \max\nolimits_{v\in V^\prime}\left(den(Qstar(i), v)\right)
\end{equation}


\textbf{基于 $lBound$ 的 CSM-TopK 搜索策略}

在此基础上，我们提出了面向CSM-TopK查询的搜索策略，该策略利用 $lBound$ 来优化搜索过程。
对于每个部分匹配 $g^i$，我们始终为每个尚未匹配的查询顶点维护一个局部候选集（Local Candidate Set）。


\begin{definition} [局部候选集] \label{def:local-candidate-set}
    %Consider a graph $G_t$, query $Q$, and 
    假设部分匹配 $g^i=\{v_1, v_2, \dots, v_i\}$ 匹配查询 $q^i=\{u_1, u_2, \dots, u_i\}$。
    %under $\Phi=$ \{$u_1, u_2$, $\cdots, u_{|V_Q|}$\} ($i<|V_Q|$).
    设 $f$ 表示  $V_{q^i}$  到 $V_{g^i}$ 之间的双向映射，即 $f(u_{i^\prime})$ $=v_{i^\prime}$ ($1\leq i^\prime\leq i$)。
    则每个尚未匹配的查询顶点 $u_j \in V_Q\setminus V_{q^i}$（即 $j>i$）的 局部候选集 $C_{g^i}(u_j)$ 定义如下：
    \begin{equation} \label{equation:local-candidate-set}
    \begin{multlined}
    C_{g^i}(u_j) = \bigcap\nolimits_{u_{i^\prime}\in LN(u_j)\cap V_{q^i}} \left(N_{G_t}^{L(u_j)}\left(f(u_{i^\prime}\right)\right) \setminus V_{g^i}
    \end{multlined}
    \end{equation}
    其中，$N_{G_t}^{L(u_j)}(f(u_{i^\prime}))$ 表示数据图中 $f(u_{i^\prime})$（即 $v_{i^\prime}$）的所有邻居集合，且这些邻居的标签必须为 $L(u_j)$。
\end{definition}


根据定义 \ref{def:local-candidate-set}，我们可以看到$C_{g^i}(u_{i+1})$ 恰好是查询顶点 $u_{i+1}$ 最大的可行候选集，用于将 $g^i$ 扩展为一系列新的 $g^{i+1}$，即：

$g^{i+1}\in$ $g^i\times C_{g^i}(u_{i+1})$

此外，我们提出以下引理 \ref{lemma:local-candidate-set}，它对于设计CSM-TopK 搜索策略至关重要。

\begin{lemma} \label{lemma:local-candidate-set}
    假设 $g^i=$ \{$v_1, v_2$, $\cdots, v_i$\} 是匹配 $q^i$的部分匹配.
    若 $g=\{v_1, v_2, \dots, v_{|V_Q|}\}$ 是包含 $g^i$ 的完全匹配，则对于 $V_g\setminus V_{g^i}$ 中的每个 $v_j$，若 $v_j$ 对应查询顶点 $u_j$，那么必然有：
       $v_j\in$ $C_{g^i}(u_j)$.
    \end{lemma}

\begin{proof}
        对于两个数据顶点 $v_{i^\prime}$ 和 $v_j$， 其中 $v_{i^\prime}\in$ $V_{g^i}$ ，  $v_{i^\prime}$ 匹配$u_{i^\prime}$ 
            且 $v_{j}\in$ $V_{g}\setminus V_{g^i}$ ， $v_{j}$ 匹配 $u_j$ ($i^\prime\leq i<j$), 
            如果 $(u_{i^\prime}, u_j)\in E_Q$ (即, $u_j\in$ $RN(u_{i^\prime})$), 则 $v_j$ $\in N_{G_t}^{L(u_j)}(v_{i^\prime})$, 即 $v_j$ 必须是 $v_{i^\prime}$ 的邻居，标签为$L(u_j)$。
            因此，根据公式\ref{equation:local-candidate-set}，$v_j$ 将是$C_{g^i}(u_j)$中的顶点。
\end{proof}

\textbf{利用局部候选集计算新的界限}

在定义 \ref{def:local-candidate-set} 和引理 \ref{lemma:local-candidate-set} 的基础上，在我们的递归搜索过程中，对于每一个部分匹配 $g^i$，我们可以为每个尚未匹配的查询顶点不断维护一个局部候选集，以加速 CSM-TopK 搜索。
通过这种局部候选集的维护，我们能够有效地剪枝搜索空间，避免无效计算。
一种可能的新的剪枝策略是，当局部候选集为空时，则当前部分匹配不可能扩展为完全匹配，因此，我们可以安全地剪枝当前的部分匹配上的搜索分支，避免浪费时间在不可能得到结果的分支上。

更进一步，局部候选集不仅能够帮助我们做出剪枝决策，还能够用于计算更为严格的密度上界。
传统的 $gBound$ 上界虽然能够提供搜索的粗略限制，但局部候选集 $C_{g^i}(u_j)$ 通过结合邻居信息，可以提供更为精确的密度上界，称为 $lBound$。
这一上界是基于部分匹配 $g^i$ 的密度以及每个未匹配查询顶点的候选集 $C_{g^i}(u_j)$ 来计算的，比起 $gBound$ 更为严格，能够有效地减少不必要的匹配扩展。

为了形式化这一概念，考虑一个完全匹配 $g={v_1, v_2, \cdots, v_{|V_Q|}}$，其中 $g^i$ 是其一个部分匹配。
对于每一个包含部分匹配 $g^i$ 的完全匹配 $g=\{v_1, v_2, \cdots, v_{|V_Q|}\}$，很明显 $v_j$（$i < j$）必须在 $C_{g^i}(u_j)$ 中，因此我们可以得出以下结论：
\begin{equation*}
    \begin{aligned}
      den(Dstar(g^\prime, j)) & \leq \max\nolimits_{v_{j^\prime}\in C_{g^i}(u_j)}\left(den(Qstar(j), v_{j^\prime})\right) \\
        & \leq den(Qstar(j), C_{g^i}(u_j))
    \end{aligned}
\end{equation*}


其中 $Dstar(g^\prime, j)$ 是 $g$ 的一个子图 $g^\prime$，其中 $g^\prime$ 匹配 $Qstar(j)$（见公式 \ref{equation:dstar-decompose}），$den(Qstar(j), v_{j^\prime})$ 表示 $Qstar(j)$ 与 $v_{j^\prime}$ 匹配时的最大密度（见公式 \ref{equation:den-qstar-v}）。
\inull{
\begin{theorem} \label{theorem:local-bound}
考虑图 $G_t$、查询 $Q$ 以及相应的匹配顺序 $\Phi$。
假设 $g^i$ 是在 $\Phi$ 下与 $q^i$ 匹配的部分匹配，
并且 $g_{max}$ 是 $g^i$ 可以扩展成的最大密度的完整匹配。
则可以得出结论：

den(g_{max}) \leq den(g^i) + \sum\nolimits_{j=i+1}^{|V_Q|} \left(den(Qstar(j), C_{g^i}(u_j))\right)

\end{theorem}
} 
因此，若 $g_{max}$ 是包含 $g^i$ 的密度最大的匹配，那么：
\[
	den(g_{max}) \leq den(g^i) + \sum\nolimits_{j=i+1}^{|V_Q|} \left(den(Qstar(j), C_{g^i}(u_j))\right)
\]

同时，对于每一个部分匹配 $g^i$，我们可以计算出它能够扩展为的一个完全匹配的密度上界。
我们用 $lBound_{G_t, Q, \Phi}(g^i)$ 来表示这个界限，即：
\begin{equation*}
    \begin{multlined}
    lBound_{G_t, Q, \Phi}(g^i) \\ = den(g^i) + \sum\nolimits_{j=i+1}^{|V_Q|} \left(den(Qstar(j), C_{g^i}(u_j))\right)
    \end{multlined}
    \end{equation*}
为了简便起见，当上下文明确时，通常将其简写为 $lBound(g^i)$。
需要注意的是，若 $C_{g^i}(u_j)$ 被标记为未定义，则在计算 $lBound(g^i)$ 时，我们将 $den(Qstar(j), C_{g^i}(u_j))$ 替换为 $den(Qstar(j))$（来自全局的 MWstar）。

通常，$lBound(g^i)$ 比 $gBound(g^i)$ 更为紧凑。
原因在于， $C_{g^i}(u_j)$ 是通过几个邻居集的交集构成的（见定义 \ref{def:local-candidate-set}），因此 $|C_{g^i}(u_j)|$ 通常不会大于平均度，而平均度远小于 $|V_{G_t}|$。
此外，在现实世界的大型图中，$|V_{G_t}|$ 通常比 $G_t$ 的平均度大一千倍以上。
因此，$den(Qstar(j), C_{g^i}(u_j))$ 通常远小于 $den(Qstar(j), V)) = den(Qstar(j))$，从而 $lBound(g^i)$ 通常比 $gBound(g^i)$ 更为紧凑。

\begin{figure}[h!]
\centering
\resizebox{0.9\linewidth}{!}{
\includegraphics{\csmfolder searching_space_example.pdf}
}
\caption{基于 MWstar 的剪枝示例}
\label{fig:exp:mwstar:pruning}
\end{figure}

考虑图 \ref{fig:csm-topk} 中的运行示例。
在图 \ref{fig:exp:mwstar:pruning} 中，我们展示了一个基于 MWstar 的剪枝策略的应用示例。在该示例中，我们考虑了执行更新操作 $o_t = <+,v_1,v_2>$ 时，CSM-TopK 搜索树的演变过程。
搜索从 部分匹配$g^2=\{v_1, v_2\}$ 开始，匹配查询 $q^2=\{u_1, u_2\}$，其中匹配序列为 $\Phi=\{u_1, u_2, u_3, u_4\}$。
我们可以通过以下步骤来评估剪枝效果：
\begin{itemize}
\item
\textcircled{1} 若没有 MWstar 索引，搜索树的扩展非常庞大。首先计算 $C_{g^2}(u_3)=\{v_5, v_6, v_7, v_8\}$，并将 $g^2$ 扩展为四个新的搜索分支。
接着，对于每一个 $g^3 \in g^2 \times C_{g^2}(u_3)$，可行候选集 $C_{g^3}(u_4)$ 为 $\{v_{1001}, \cdots, v_{2000}\}$。
因此，每个 $g^3$ 将扩展为 $1000$ 个新的搜索分支。
没有 MWstar索引时，基于 $g^2$ 的搜索树中可能会有超过 $4000$ 个节点。
\item
\textcircled{2} 若仅使用全局 MWstar 索引，则可以通过计算每个扩展的 $gBound$，提前剪掉一些不可能的分支，减少搜索空间。
对于 $q^3$ 下的四个分支，即 $g_1^3=\{v_1, v_2, v_5\}$、$g_2^3=\{v_1, v_2, v_6\}$、$g_3^3=\{v_1, v_2, v_7\}$、$g_4^3=\{v_1, v_2, v_8\}$，
我们有 $gBound(g_3^3)=gBound(g_4^3)=50+10+10+den(Qstar(4))=130$，这个值小于 $den(g_{min})=140$，其中 $g_{min}=\{v_1, v_3, v_6, v_9\}$，如图 \ref{fig:csm-topk}c 所示。
因此，$g_3^3$ 和 $g_4^3$会立即被剪枝。
而$g_1^3$ 和 $g_2^3$ 不会被剪枝，因为 $gBound(g_1^3) = gBound(g_2^3) = 50+20+20+den(Qstar(4)) = 150 > 140$。
因此，使用全局 MWstar 时，搜索空间的大小接近 $2000$。
\item
\textcircled{3} 若结合全局和局部 MWstar 索引后，计算 $lBound$ 并进行剪枝，能够显著缩小搜索空间。
在我们从 $g^2$ 开始进行搜索时，
我们首先计算 $C_{g^2}(u_3)=\{v_5, v_6, v_7, v_8\}$，并且 $den(Qstar(3), C_{g^2}(u_3)) = 50$。
同样，$C_{g^2}(u_4)=\{v_{1001}, \cdots, v_{2000}\}$，并且 $den(Qstar(4), C_{g^2}(u_4)) = 20$。
因此，$lBound(g^2)=den(g^2)+50+50+20=120<140$，因此 $g^2$ 会被剪枝。
在这种情况下，总的搜索空间可以忽略不计。
这一过程表明，基于MWstar的剪枝策略能够显著减少搜索空间，避免对不够密集的匹配进行无效的计算，从而提升了算法的效率。
\end{itemize}

在递归搜索过程中，我们为每一个部分匹配 $g^i$中的未匹配的查询顶点 $u_j$（即 $u_j \in V_Q \setminus V_{q^i}$）维护一个局部候选集。
这些局部候选集将与MWstars一起使用，以便尽早修剪掉那些不太可能的部分匹配。算法 \ref{alg:localmwstar:framework} 中提供了这种面向CSM-TopK搜索的伪代码实现。

具体而言，对于一个部分匹配 $g^2 = \{v_1, v_2\}$，我们根据公式 \ref{equation:local-candidate-set} （算法 \ref{alg:localmwstar:framework} 中的第 \ref{code:init-lcs:begin}-\ref{code:init-lcs:end} 行）初始化每个未匹配查询顶点的局部候选集（即 $u_3$，$u_4$，$\cdots$，$u_{|V_Q|}$）。
如果某个未匹配的查询顶点 $u_j$ 在 $V_{g^2}$ 中没有左邻居（即 $\{u_1, u_2\}$），我们将相应的 $C_{g^2}(u_j)$ 标记为未定义。
正如前所述，如果 $C_{g^i}(u_j)$ 被标记为未定义，我们在计算 $lBound(g^i)$ 时将 $den(Qstar(j), C_{g^i}(u_j))$ 替换为 $den(Qstar(j))$（来自全局 MWstar）。
随后，我们可以从 $g^2$ 开始递归地进行 面向CSM-TopK 的搜索。

\begin{algorithm}[H]
    \small
    \caption{基于全局和局部 MWstars 的 CSM-TopK 搜索算法}
    \label{alg:localmwstar:framework}
    \KwIn{一个动态图 $\iG = (G_0, \Delta)$，查询图$Q$ 和 参数$k$}
    \KwOut{对于每个 $G_t$，报告 $A^k_t = {g_1, g_2, \ldots, g_k}$}
    % \tcc{离线预处理}
    BuildMatchingOrder($Q$, $u_1$, $u_2$) 对于每个 $(u_1, u_2) \in Q$ \\
    BuildMWstar($G_0$, $Q$, $\Phi$) 对每个 $\Phi$  \\
    计算 $A_0^k$ 在 $G_0$ 上的查询 $Q$ \\
    % \tcc{在线预处理}
    \ForEach{$o_t = (op, v_1, v_2) \in \Delta$}{
    应用 $o_t$ 到 $G_{t-1}$ 形成 $G_t$，并更新 MWstar \\
    初始化 $A^k_{t}$ 为 $A^k_{t-1}$ \\
    \If{$op = +$}{
    \ForEach{$(u_1, u_2) \in E_{Q_t}$ 匹配 $(v_1, v_2)$} {\label{local:code:baseline:begin}
    令 $g^2 = {v_1, v_2}$ \\
    设 $v_1$，$v_2$ 为已访问\\
    令 $\Phi$ 为匹配序列，并从 $u_1$，$u_2$ 开始 \\
    \ForEach{$u_j \in V_Q \setminus V_{q^2}$}{ \label{code:init-lcs:begin}
    根据定义 \ref{def:local-candidate-set} 初始化 $C_{g^2}(u_j)$ \label{code:init-lcs:end}
    }
    FindDenseMatches-Both$(G_t, Q, \Phi, g^2, A_t^k, k)$ \label{local:code:baseline:end} \
    /* 见算法 \ref{alg:find-dense-matches-formal} 获取详细过程 */
    }
    }
    \If{$op = -$}{
    执行与算法 \ref{alg:baseline:framework} 中第 \ref{code:base-del:begin}-\ref{code:base-del:end} 行对称的操作
    }
    }
    \end{algorithm}

对于每个部分匹配 $g^i$，如果满足以下任意条件之一，我们可以安全地剪枝 $g^i$：
\begin{itemize}
\item \textcircled{1} 有一个局部候选集为空（算法 \ref{alg:find-dense-matches-formal} 中的第 \ref{code:lcs-empty:begin}-\ref{code:lcs-empty:end} 行），
\item \textcircled{2} $lBound(g^i)$ 小于当前密度下界（算法 \ref{alg:find-dense-matches-formal} 中的第 \ref{code:B-formal:begin}-\ref{code:B-formal:end} 行）。
\end{itemize}
如果 $g^i$ 未被剪枝，则可以利用已经计算好的可行候选集 $C_{g^i}(u_{i+1})$ 将 $g^i$ 扩展为若干个 $g^{i+1}$，继续递归搜索。

对于每个 $g^{i+1} = g^i \cup {v_{i+1}}$，其中 $v_{i+1} \in C_{g^i}(u_{i+1})$，我们将按以下方式更新每个 $u_j$（$j > i+1$）的局部候选集：
如果 $u_j \notin RN(u_{i+1})$，则无需执行任何操作；否则，如果 $u_j \in RN(u_{i+1})$（算法 \ref{alg:find-dense-matches-formal} 中的第 \ref{code:formal-each-rn:begin}-\ref{code:formal-each-rn:end} 行）：
\begin{itemize}
\item 如果 $u_j$ 的局部候选集未定义，则基于访问性的过滤将 $C_{g^{i+1}}(u_j)$ 设置为 $N_{G_t}^{L(u_j)}(v_{i+1})$，即 $v_{i+1}$ 的邻居的标签都为 $L(u_j)$。
\item 如果 $u_j$ 的局部候选集已存在，则根据定义 \ref{def:local-candidate-set}，我们使用基于访问性的过滤，将 $C_{g^{i+1}}(u_j)$ 设置为 $C_{g^i}(u_j) \cap N_{G_t}^{L(u_j)}(v_{i+1})$。
\end{itemize}

\begin{algorithm}[H]
    \scriptsize
    \caption{利用 $lBound$ 进行递归搜索}
    \label{alg:find-dense-matches-formal}
    \SetKwBlock{iFunc}{Procedure}{End Procedure}
    \iFunc(FindDenseMatches-Both{(}$G_t, Q, \Phi, g^i, A, k${)})
    {
    令 $g_{min}$ 为 $A$ 中密度最小的匹配 \\
    \If{$|g^i|=|V_Q|$}{
    \If{$|A|<k \lor den(g_{min}) < den(g^i)$ } {
    将 $g^i$ 添加到 $A$ 中 \\
    若 $|A|>k$，则从 $A$ 中移除 $g_{min}$\
    \Return
    }
    }
    初始化 $lBound(g^i)$ 为 $den(g^i)$\
    \ForEach{$u_{j} \in V_Q \setminus V_{q^i}$}{ \label{code:lcs-empty:begin}
    \If{$C_{g^i}(u_j) = \emptyset$}{
    \Return   \label{code:lcs-empty:end}
    }
    \If{$C_{g^i}(u_j)$ 未定义}{
    /* 来自全局 MWstar 的密度 */ \\
    $lBound(g^i) += den(Qstar(j))$
    }
    \Else{
                    /* 来自局部 MWstar 的密度 */  \\
    $lBound(g^i) += den(Qstar(j), C_{g^i}(u_j))$
    }
    
    }
    
    \If{$|A|=k \land lBound(g^i) \leq den(g_{min})$}{ \label{code:B-formal:begin}
        \Return \label{code:B-formal:end}
    }
    \ForEach{$v_{i+1} \in C_{g^i}(u_{i+1})$}{ \label{code:formal-extension:begin}
    将 $v_{i+1}$ 标记为已访问，并令 $g^{i+1} = g^i \cup {v_{i+1}}$ \\
    \ForEach{$u_{j} \in RN(u_{i+1})$}{ \label{code:formal-each-rn:begin}
    \If{$C_{g^{i}}(u_{j})$ 未定义}{
        $C_{g^{i+1}}(u_{j}) = N_{G_t}^{L(u_{j})}(v_{i+1})$ 
    }
    \Else{
        $C_{g^{i+1}}(u_{j}) = C_{g^{i}}(u_{j}) \cap N_{G_t}^{L(u_{j})}(v_{i+1})$ \label{code:formal-each-rn:end}
    }
    $C_{g^{i}}(u_{j}) =$ $(C_{g^{i}}(u_{j})).filterVisited()$
    }  
    FindDenseMatches-Both{(}$G_t, Q, \Phi, g^{i+1}, A, k${)} \\ 
    将 $v_{i+1}$ 标记为未访问 \label{code:formal-extension:end}  \\
    }
    
    \Return 
    
    }
    \end{algorithm}



在整个过程中，一共有 $|E_Q|$ 个匹配序列，每个数据顶点 $v_i$ 在某一匹配序列下有 $|V_Q|$ 个密度（即每个 $u_j$ 的 $den(Qstar(j, v_i))$）。
因此，算法的空间复杂度显然是 $O(|E_Q|*|V_{G_t}|*|V_Q|)$，这是与数据图的顶点数量成线性关系的。
实际上，局部 MWstar 的维护也是高效的。考虑一个更新 $o_t = (op, v_1, v_2)$，其中 $(v_1, v_2)$ 匹配 $(u_{i_1}, u_{i_2})$。
如果 $o_t$ 是插入操作，即 $op = +$，对于每个匹配序列 $\Phi$，假设 $u_{i_1} \in LN(u_{i_2})$（我们省略对称情况的讨论），我们可以在 $O(d_t)$ 时间内更新 $den(Qstar(i_2), v_2)$（算法 \ref{alg:base-mwstar:update} 中第 \ref{code:basic-den-update:begin}-\ref{code:basic-den-update:end} 行），其中 $d_t$ 是 $G_t$ 的平均度数。
由于有 $|E_Q|$ 个匹配序列，边插入时局部 MWstar 的维护需要 $O(|E_Q| * d_t)$ 平均时间。

如果 $o_t$ 是删除操作，即 $op = -$，对于每个匹配序列 $\Phi$，如果 $u_{i_1} \in LN(u_{i_2})$（对称情况的讨论省略），我们可以在 $O(d_t)$ 时间内更新 $den(Qstar(i_2), v_2)$。
因此，删除操作的时间复杂度是 $O(|E_Q| * d_t)$，几乎是常数时间。

\section{图压缩技术}
\label{mwstar:compact-graph}

本节将探讨如何将每个图$G_t$上的CSM-TopK搜索问题转化为在压缩图$\cG_t$及其对应的新查询$\cQ$上进行的更高效的搜索。
通过这种方法，我们能够显著减降低图表示和存储的空间开销。
首先，$\cQ$与$Q$具有相同的顶点集和边集，唯一的不同在于新的标签函数$\cL_{\cQ}$（当上下文明确时简写为$\cL$），其中$\cQ$中的每个查询顶点都被赋予了新的唯一标签。
在不失一般性的情况下，我们假设$\cL(u_j) = l_j^{new}$。
因此，$\cQ = {V_Q, E_Q, \cL}$。



为了在压缩图$\cG_t$中进行更高效的搜索，我们首先在图$G_0$的基础上构建了初始的压缩图$\cG_0$，而对于$t>0$，$\cG_t$是通过一系列基于$o_t$的调整从$\cG_{t-1}$转化而来。
这些调整可以包括删除无希望的顶点以及边，从而压缩图的规模，优化搜索过程。
在压缩图$\cG_t$上进行的$\cQ$搜索，不仅能有效地返回正确的$A_{G_t, Q}^k$，而且大幅降低了搜索所需的空间开销、搜索时间以及维护开销。

\subsection{压缩图构建}
\label{s-sec:compact-graph-construction}

在这一部分中，我们详细讨论如何在$G_t$和$Q$上构建压缩图$\cG_t$。构建过程包括数据顶点的匹配关系、压缩图的顶点集和边集的构造。

我们用$\tau$表示$\cG_t$中的一个数据顶点，用$\cg$表示$\cG_t$中的一个子图。
每个顶点$\tau \in V_{\cG_t}$都对应着$V_{G_t}$中的一个数据顶点和$V_Q$中的一个查询顶点之间的匹配关系，即图$G_t$中的数据顶点$v_i$和查询图$Q$中的查询顶点$u_j$之间的匹配关系。
我们使用$\langle v_i, u_j \rangle$来表示一个匹配关系，其中$v_i$与$u_j$匹配，其中$v_i$是$u_j$的候选数据顶点。
为了确保数据顶点$v_i$和查询顶点$u_j$之间的匹配关系合理，我们引入了邻域标签频率过滤（NLF）~\cite{sgi-turbo-iso-DBLP:conf/sigmod/HanLL13}，即对于顶点$v_i$和查询顶点$u_j$，如果$v_i$通过了$u_j$的NLF规则~\cite{sgi-turbo-iso-DBLP:conf/sigmod/HanLL13}（即$v_i$的邻域中标签频率大于等于$u_j$的邻域标签频率），则称$v_i$是$u_j$的NLF候选（NLF-candidate），即：
$v_i$匹配$u_j$，并且对于任何标签$l$（在$L_Q$下，而不是$\cL_{\cQ}$），有$|N_{G_t}^l(v_i)| \geq |N_Q^l(u_j)|$。

每个顶点$\tau \in V_{\cG_t}$恰好对应一个唯一的匹配关系$\langle v_i, u_j \rangle$，其中$v_i$是$u_j$的NLF候选。
在此基础上，我们将$\cL(\tau)$设置为$u_j$在$\cQ$中的标签，即$l_j^{new}$。
因此，我们可以按以下方式构建$V_{\cG_t}$：首先将$V_{\cG_t}$初始化为空集，并枚举$v_i$和$u_j$的所有匹配对。
如果$v_i$是$u_j$的NLF候选，则在$V_{\cG_t}$中创建一个新的顶点$\tau_{i^\prime}$，其标签为$\cL(\tau_{i^\prime}) = l_j^{new}$。

接下来，我们基于$V_{\cG_t}$构建$\cG_t$中的边集$E_{\cG_t}$。
考虑两个顶点$\tau_1$和$\tau_2$，它们对应的匹配关系分别为$\langle v_{i_1}, u_{j_1} \rangle$和$\langle v_{i_2}, u_{j_2} \rangle$。
当且仅当$(v_{i_1}, v_{i_2}) \in E_{G_t}$且$(u_{j_1}, u_{j_2}) \in E_Q$时，$E_{\cG_t}$中存在一条边$(\tau_1, \tau_2)$。
显然，$E_{\cG_t}$中的边$(\tau_1, \tau_2)$表示数据图中的边$(v_{i_1}, v_{i_2})$与查询边$(u_{j_1}, u_{j_2})$之间的匹配关系。
此时，将边$(\tau_1, \tau_2)$的权重设置为边$(v_1, v_2)$的权重，即$W_{v_1, v_2}$。

图\ref{fig:compact}中展示了图\ref{fig:csm-topk}a中的运行示例对应的压缩图$\cG_t$以及新查询图$\cQ$。
我们可以观察到，$\tau_1$对应着$\langle v_1, u_1 \rangle$，因为$v_1$是$u_1$的NLF候选。
同时，$V_{\cG_t}$中没有与$v_{10}$或$v_{11}$相关的顶点，因为它们都不是任何查询顶点的NLF候选。

\begin{figure}[h!]
\def\wscorevone{0.62}
\centering
\begin{subfigure}[t]{\wscorevone\linewidth}
\centering
\resizebox{\linewidth}{!}
{
\includegraphics{\csmfolder data_compact_graph.pdf}
}
\caption{压缩图$\cG_t$}
\label{fig:data_compact_graph}
\end{subfigure}
\begin{subfigure}[t]{0.35\linewidth}
\centering
\resizebox{\linewidth}{!}
{
\includegraphics{\csmfolder query_compact_graph.pdf}
}
\caption{新查询图$\cQ$}
\label{fig:query_compact_graph}
\end{subfigure}
\caption{压缩图和新查询示例}
\label{fig:compact}
\end{figure}


\subsection{压缩图构建}
在这一部分中，我们讨论如何在压缩图$\cG_t$上进行CSM-TopK搜索，从而计算目标密集答案$A_{G_t, Q}^k$。

我们假设$\cG_t$上的MWstar已经构建完成。
对于一个子图$\cg = \{\tau_1, \tau_2, \dots, \tau_{|V_{\cQ}|}\}$，我们假设$\tau_x$对应匹配关系$\langle v_{i_x}, u_{j_x} \rangle$（$1 \leq x \leq |V_{\cQ}|$）。在这里，$v_{i_x}$表示图$G_t$中的数据顶点，而$u_{j_x}$是查询图$Q$中的顶点。
我们可以推测，如果$g = \{v_{i_1}, v_{i_2}, \dots, v_{i_{|V_Q|}}\}$是$Q$在$G_t$上的一个匹配，且$\Phi = \{u_{j_1}, u_{j_2}, \dots, u_{j_{|V_Q|}}\}$，那么$\cg$一定是$\cQ$在$\cG_t$上的匹配。
然而，反过来并不成立，也就是说，当$\cg$是$\cQ$在$\cG_t$上的匹配时，它对应的$g$可能不是$Q$的匹配。
具体来说，对于子图$V_{\cg}$中的两个不同的顶点$\tau_x$和$\tau_y$，它们对应的数据顶点$v_{i_x}$和$v_{i_y}$可能是相同的（即$v_{i_x} = v_{i_y}$），这将导致同构映射$f(u_{j_{x^\prime}}) = v_{i_{x^\prime}}$（$1 \leq x^\prime \leq |V_Q|$）, 从而从同构映射降级为同态映射~\cite{homomorphism-DBLP:conf/soda/CyganFGKMPS16}。

因此，我们需要一种有效的策略来保证搜索仅返回其对应的$g$与$Q$在$G_t$中完全同构的$\cg$。
为了实现这一点，我们通过扩展$V_{\cG_t}$中数据顶点的访问状态到对应的$V_{G_t}$中的数据顶点，来保证对应的$V_{G_t}$中的数据顶点一致性。
这意味着，对于$V_{G_t}$中的每个数据顶点$v_{i_x}$，我们在$V_{\cG_t}$中维护一个顶点计数，表示$v_{i_x}$与某些查询顶点之间的匹配关系。
我们称此计数为$v_{i_x}$的\emph{访问计数}。
具体而言，对于每个顶点$\tau_x$，如果它对应的匹配关系为$\langle v_{i_x}, u_{j_x} \rangle$，当我们需要标记$\tau_x$为已访问时，我们会同时增加$v_{i_x}$的访问计数；
而当我们将$\tau_x$重置为未访问时，我们减少$v_{i_x}$的访问计数。
当我们对候选集进行访问检查时（例如公式 \ref{equation:wcoj-intersection} 和 \ref{equation:local-candidate-set}），我们会过滤掉那些访问计数大于 0 的 $\tau_x$。
显然，访问扩展是非常简单的，并且对搜索的额外时间消耗可以忽略不计。
\begin{theorem} \label{theorem:reduce-correctness}
假设 $A_{\cG_t, \cQ}^k$ 包含通过我们的CSM-TopK搜索算法（算法 \ref{alg:localmwstar:framework}）在 $\cG_t$ 和 $\cQ$ 上得到的前 $k$ 个答案，并且已应用了访问扩展，
那么对于 $A_{\cG_t, \cQ}^k$ 中的每个子图 $\cg=$ \{$\tau_1$, $\tau_2$, $\cdots$, $\tau_{|V_{\cQ}|}$\}，
其中 $\tau_{x}$ 对应于匹配关系 $\langle v_{i_x}$, $u_{j_x}\rangle$（$1\leq x\leq |V_{\cQ}|$），
相应的节点集合$g=$ \{$v_{i_1}$, $v_{i_2}$, $\cdots$, $v_{i_{|V_Q|}}$\} 必须是 $A_{G_t, Q}^k$ 中的一个有效匹配，并且满足 $den(g) = den(\cg)$。
\end{theorem}
\begin{proof}
设 $f$ 表示从 $V_{\cQ}$ 到 $V_{\cg}$ 的双向映射，即 $f(u_x) = \tau_x$ （$1\leq x\leq |V_Q|$）。
我们可以构建一个从 $V_{\cg}$ 到集合 \{$v_{i_1}$, $v_{i_2}$, $\cdots$, $v_{i_{|V_Q|}}$\} 的映射 $f^{\prime}$，其中 $f^{\prime}(\tau_x) = v_{i_x}$。
由于我们在搜索 $\cg$ 时应用了访问扩展，确保对于任意 $1\leq x<y\leq |V_Q|$，$v_{i_x} \neq v_{i_y}$， $f^{\prime}$ 也是双射的。
因此，设新的映射 $f^{new} = f \cdot f^\prime$，那么 $f^{new}$ 将是 $V_Q$ 和满足子图匹配约束的集合 \{$v_{i_1}$, $v_{i_2}$, $\cdots$, $v_{i_{|V_Q|}}$\} 的双射映射。
\end{proof}
定理 \ref{theorem:reduce-correctness} 保证了我们在压缩图上的搜索的正确性。

例如，图 \ref{fig:compact} 中的 $\cG_t$ 和 $\cQ$ 对应的 $A_{\cG_t, \cQ}^3$ 包含 $\cg_1=$\{$\tau_1$, $\tau_3$, $\tau_4$, $\tau_9$\}，$\cg_2=$\{$\tau_1$, $\tau_3$, $\tau_5$, $\tau_9$\} 和 $\cg_3=$\{$\tau_1$, $\tau_3$, $\tau_6$, $\tau_9$\}，我们可以看到，对应的 $g_1$、$g_2$ 和 $g_3$ 正好构成图 \ref{fig:csm-topk} 中的 $A_{G_t, Q}^3$。

\subsection{压缩图维护}
在这一小节中，们将详细探讨如何根据每个更新操作 $o_t$（$t>0$）调整图 $\cG_{t-1}$ 以生成新的图 $\cG_t$。
特别地，我们将讨论如何处理图 $\cG_t$ 上的 MWstars 更新，图 $\cG_{t-1}$ 上的更新操作如何影响压缩图结构的调整，以及边的插入和删除是如何影响图的维护。
对于压缩图上的 MWstars 维护，过程与我们之前的讨论完全一致。
假设我们已经在 $\cG_{t-1}$ 上构建了全局和局部的 MWstar。
现在考虑一个更新操作 $o_t=$ $(op, v_{i_1}, v_{i_2})$，其中 $v_{i_1}$ 和 $v_{i_2}$ 分别与 $u_{j_1}$ 和 $u_{j_2}$ 匹配。
%
我们首先集中讨论 $E_{\cG_{t-1}}$ 上的边插入/删除（由 $o_t$ 引起的）。这些边的更新将 $\cG_{t-1}$ 转换为 $\cG_t$。

\subsubsection{插入操作}
如果 $o_t$ 是一个插入操作，
我们首先检查 $v_{i_1}$ （或 $v_{i_2}$）是否是$G_t$上$u_{j_1}$（或 $u_{j_2}$）的 NLF 候选，如果是，则按照以下步骤对 $E_{\cG_{t-1}}$ 进行调整：
\begin{itemize}
\item \textcircled{1} 我们首先将更新操作$o_t$应用到图$G_{t-1}$，生成新的图 $G_t$，然后初始化 $\cG_t = \cG_{t-1}$。
\item \textcircled{2} 如果 $v_{i_1}$ 不是 $u_{j_1}$ 的 NLF 候选者，且 $v_{i_2}$ 也不是 $u_{j_2}$ 的 NLF 候选者，则$o_t$在$\cG_{t-1}$上不会有任何更新，我们可以直接结束当前更新。
\item \textcircled{3} 如果 $v_{i_1}$（对称情况是 $v_{i_2}$）是 $u_{j_1}$ 的一个新的 NLF 候选者，
即在 $V_{\cG_{t-1}}$ 中没有与 $\langle v_{i_1}, u_{j_1} \rangle$ 相对应的顶点，
那么我们将在 $\cG_t$ 中为 $\langle v_{i_1}, u_{j_1} \rangle$创建一个标签为$i_1$的新顶点 $\tau_1$。
新顶点 $\tau_1$ 的加入可能会导致新的边加入到 $\cG_t$。
我们可以遍历 $v_{i_1}$ 在 $G_t$ 中的邻居，并为每个 $v_{i_3}\in N_{G_t}(v_{i_1})$，
计算所有匹配对 $\langle v_{i_3}, u_{j_3} \rangle$，使得 $u_{j_3}$ 是 $u_{j_1}$ 的邻居，并且 $v_{i_3}$ 是 $u_{j_3}$ 的 NLF 候选者。
这样，我们可以将每条边 $(\tau_1, \tau_3)$ 添加到 $\cG_t$，其中 $\tau_3$ 是对应于 $\langle v_{i_3}, u_{j_3} \rangle$ 的顶点。
\item \textcircled{4} 如果 $v_{i_1}$ 和 $v_{i_2}$ 分别是 $u_{j_1}$ 和 $u_{j_2}$ 的 NLF 候选者，并且它们都不是新的，那么我们将把边 $(\tau_1, \tau_2)$ 添加到 $\cG_t$，其中 $\tau_1$ 和 $\tau_2$ 分别对应于 $\langle v_{i_1}, u_{j_1} \rangle$ 和 $\langle v_{i_2}, u_{j_2} \rangle$两个顶点。
\end{itemize}

这些步骤保证了插入操作后的图结构的正确性，并且通过逐步将新插入的边添加到图中，我们能够确保图 $\cG_t$ 是对图 $\cG_{t-1}$ 的正确扩展。

在插入新边到 $E_{\cG_t}$ 后，我们可以继续更新 $\cG_t$ 的 MWstars。
由于更新操作 $o_t$ 可能会导致 $\cG_t$ 中引入多条新边。
具体地，设 $E_1$ 和 $E_2$ 分别表示与 $\tau_1$ 和 $\tau_2$ 相邻的两组新插入的边，
其中 $\tau_1$（或 $\tau_2$）是 $V_{\cG_t}$ 中对应于 $\langle v_{i_1}, u_{j_1} \rangle$（或 $\langle v_{i_2}, u_{j_2} \rangle$）的顶点
\footnote{如果 $\tau_1$（或 $\tau_2$）不存在，我们设定 $E_1$（或 $E_2$）为 $\emptyset$。}。

一种直接的方法是从每个新插入的边开始在 $E_1 \cup E_2$ 中进行搜索。
然而，正如定理 \ref{theorem:only-one-edge-to-search} 所指出的，这种朴素策略会导致大量冗余计算。因此，我们需要采取更有效的策略，避免不必要的重复搜索。

\begin{theorem} \label{theorem:only-one-edge-to-search}
    考虑一个更新操作 $o_t = (op, v_{i_1}, v_{i_2})$，其中 $v_{i_1}$ 和 $v_{i_2}$ 分别与 $u_{j_1}$ 和 $u_{j_2}$ 匹配。
    对于每个新的匹配 $\cg \in A_{\cG_t, \cQ} \setminus A_{\cG_{t-1}, \cQ}$，$\cg$ 必须包含新插入的边 $(\tau_1, \tau_2)$，其中 $\tau_1$ 对应于匹配关系 $\langle v_{i_1}, u_{j_1} \rangle$，而 $\tau_2$ 对应于匹配关系 $\langle v_{i_2}, u_{j_2} \rangle$。
\end{theorem}

\begin{proof}
    我们通过反证法来证明该命题。
    假设 $\cg$ 是一个新匹配，其中 $(\tau_1, \tau_2) \notin E_{\cg}$。
    为了不失一般性，我们假设 $\cg$ 是由新插入的边 $(\tau_1, \tau_3)$（其中 $\tau_3 \neq \tau_2$）引起的，其中 $\tau_3$ 对应于匹配关系 $\langle v_{i_3}, u_{i_3} \rangle$。
    由于在应用 更新操作$o_t$ 之前，边 $(v_{i_1}, v_{i_3})$ 已经存在于 $E_{G_{t-1}}$ 中，且根据我们的更新规则，
    $(\tau_1, \tau_3)$ 只有在 $\tau_1$ 是一个新创建的顶点时才会成为新插入的边。
    然而，设 $g$ 是 $\cg$ 在 $G_t$ 中的对应匹配，那么 $v_{i_1}$ 必须在 $V_g$ 中而 $v_{i_2}$ 不在，这意味着即使没有 $v_{i_2}$，$v_{i_1}$ 仍然是 $u_{j_1}$ 的 NLF 候选者。
    换句话说，$\tau_1$ 并不是一个新创建的顶点，这与假设矛盾。
    因此，证明完成。
\end{proof}

以上推理表明，在边插图过程中，我们只需要从边 $(\tau_1, \tau_2) \in E_1 \cap E_2$ 开始进行搜索，并且可以剪枝从$(E_1 \cup E_2) \setminus (E_1 \cap E_2)$中新插入的边开始的搜索分支。

\subsubsection{删除操作}
若 $o_t$ 是一个删除操作，我们按以下步骤进行维护：
\begin{itemize}
\item \textcircled{1} 在图$G_{t-1}$ 上应用更新操作$o_t$，得到图$G_t$，然后初始化 $\cG_t = \cG_{t-1}$；
\item \textcircled{2} 如果在 $\cG_{t-1}$ 中，$v_{i_1}$ 既不是 $u_{j_1}$ 的 NLF 候选者，$v_{i_2}$ 也不是 $u_{j_2}$ 的 NLF 候选者，那么我们无需做任何操作，因为 $\cG_{t-1}$ 上不会发生更新；
\item \textcircled{3} 如果某个顶点 $\tau$ 在删除边 $(v_{i_1}, v_{i_2})$ 后失效，我们需要从图 $\cG_t$ 中删除该顶点 $\tau$，并移除与 $\tau$ 相邻的边。
\end{itemize}

在每次删除边后，我们将相应地更新 MWstars。根据第 \ref{ch3:base-framework} 节中的框架，如果之前排名前 $k$ 的匹配结果已经过期，无论 $\cG_{t-1}$ 中删除了多少条边，我们只需要计算一次补充的答案。
此外，我们的重新计算是在压缩图 $\cG_t$ 上进行的，而不是在 $G_t$ 上。

压缩图是一种通过优化存储和处理方式来减少图数据规模的结构，其核心目的是在不丧失图的核心信息和特性下，减少计算和存储开销，进而提高大规模图处理的效率。
在图算法中，尤其是当处理的图非常庞大时，压缩图提供了一种有效的方式来减少内存使用并加速计算。

本文基于NLF规则提出了一种图压缩策略，每次数据图发生更新时（如插入、删除操作），压缩图会动态地对压缩图的结构进行调整（如节点和边的增加或者删除），确保图结构在更新后依然保持有效性。
在图更新过程中，我们对于压缩图的插入和删除操作的处理方式具有高效性。
对于插入操作，压缩图会检查是否有新的查询点的NLF候选者出现，若符合条件，则在图中添加新的顶点以及新的边。
对于删除操作，则会删除不再有效的边和顶点，从而保证图结构的精简和高效。
若是删除某条边，导致压缩图中的某个候选顶点不再满足NLF规则，则将其从压缩图中删除，并删除与之相关联的边。
因此，压缩图的更新并不需要完全重建图的结构，而是通过局部更新来减少不必要的计算，这显著提高了算法的性能。

当数据图的规模较大，并且查询图较复杂时，压缩图能通过维护全局和局部星形结构索引（MWstars），确保实时高效的获取密度最高的$k$个匹配。

\section{本章小结}
本章针对动态图中TopK连续子图匹配问题，提出了一种基于星形结构密度索引的高效解决方案。
首先，我们首先设计了全局MWstar索引，通过维护星形子结构的最大权重，提供了部分匹配的粗粒度密度上界 $gBound$。
接着，创新性地提出了局部MWstar索引，结合候选集的交运算缩小候选集合的大小，从而构建了更加紧凑的密度上界 $lBound$，显著减少了无效搜索空间。
更为重要的是，该索引方法具有轻量级特点，能够在常数时间内完成更新，并保持线性空间复杂度。
为进一步提升系统性能，本章还提出了动态压缩图技术。
通过NLF过滤策略，构建了规模更小的压缩图，并在该压缩图中维护了由星形结构索引构建的局部MWstar索引，使得压缩图更加紧凑。
这样不仅保证了搜索结果的正确性，还显著提高了子图匹配的搜索效率。
